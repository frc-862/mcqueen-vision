package grip.examples;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.HashMap;

import org.opencv.core.*;
import org.opencv.core.Core.*;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;
import org.opencv.objdetect.*;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

/**
* GripPipeline class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class GripPipeline {

	//Pipeline values for cv methods
	private HashMap<String, Object> params = new HashMap<>();

	//Is pipeline mutable
	private boolean isMutable = true;
	
	/**
	 * Initilize pipeline value
	 * @param name name of value
	 * @param val 
	 */
	public void initParam(String name, Object val) {
		params.put(name, val);
	}

	/**
	 * Accessor for single parameter
	 * @param name name of parameter
	 * @return {@code Object} with parameter value
	 */
	public Object getParam(String name) {
		if(isMutable) updateParams();
		return params.get(name);
	}

	/**
	 * Accessor for all parameter names
	 * @return {@code Set<String>} of all parameter names
	 */
	public Set<String> getParamNames() {
		return params.keySet();
	}

	//Outputs
	private Mat blur0Output = new Mat();
	private Mat blur1Output = new Mat();

	
	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }
    
	//Pipeline JSON name
	private static final String configFile = "GripPipelineParams.json";
	
	//Pipeline JSON root directory
	private static final String configDir = "/home/pi/pipeline-params/";
	
	//Full Pipeline JSON file path
	private static final String configFPath = configDir + configFile;

	/**
	 * This is a method that will retrieve updated pipeline values from the pipeline's JSON file
	 */
	private void updateParams() {
		Path fpath = Paths.get(configFPath);
		JsonElement top;
		try {
			//Read JSON
			top = new JsonParser().parse(Files.newBufferedReader(fpath));
			if(!top.isJsonObject()) {
				Files.deleteIfExists(fpath);
				throw new IOException();
			}
			JsonObject obj = top.getAsJsonObject();
			//Set Parameter Map To Values in JSON
			this.params = new Gson().fromJson(obj, HashMap.class);
		} catch(IOException ioe) {
            System.out.println("Could not update pipeline parameters");
            this.isMutable = false;
		}
	}

	/**
	 * Default constructor sets pipeline to mutable by default
	 */
	public GripPipeline() { this(true); }

	/**
	 * Constructor 
	 */
	public GripPipeline(boolean isMutable) {

		//JSON path
        Path fpath = Paths.get(configFPath);
        
        //JSON dir
        Path fdir = Paths.get(configDir);

		//Is pipeline mutable
		this.isMutable = isMutable;

		//Read JSON
		JsonElement top;
		try {
			top = new JsonParser().parse(Files.newBufferedReader(fpath));
			if(!top.isJsonObject()) {
				Files.deleteIfExists(fpath);
				throw new IOException();
			}
			JsonObject obj = top.getAsJsonObject();
			//Set Parameter Map To Values in JSON
			this.params = new Gson().fromJson(obj, HashMap.class);
		} catch(IOException ioe) {
			//If JSON does not exist
			try {
				//Init default pipeline values
				initParam("blur0Radius", 9.649122807017552);
				initParam("blur1Radius", 69.2982456140351);
                //Create JSON file
                if(!Files.isDirectory(fdir)) Files.createDirectory(fdir);
                if(!Files.exists(fpath)) Files.createFile(fpath);
				//Write default values
				Files.write(fpath, new Gson().toJson(this.params).getBytes(StandardCharsets.UTF_8));
			} catch (Exception e) {
				System.out.println("New File Could Not Be Created - Pipeline Will Continue Running");
			}
		}

	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	public void process(Mat source0) {
		// Step Blur0:
		Mat blur0Input = source0;
		BlurType blur0Type = BlurType.get("Box Blur");
		double blur0Radius = (double) getParam("blur0Radius");
		blur(blur0Input, blur0Type, blur0Radius, blur0Output);

		// Step Blur1:
		Mat blur1Input = blur0Output;
		BlurType blur1Type = BlurType.get("Gaussian Blur");
		double blur1Radius = (double) getParam("blur1Radius");
		blur(blur1Input, blur1Type, blur1Radius, blur1Output);

	}

	/**
	 * This method is a generated getter for the output of a Blur.
	 * @return Mat output from Blur.
	 */
	public Mat blur0Output() {
		return blur0Output;
	}

	/**
	 * This method is a generated getter for the output of a Blur.
	 * @return Mat output from Blur.
	 */
	public Mat blur1Output() {
		return blur1Output;
	}


	/**
	 * An indication of which type of filter to use for a blur.
	 * Choices are BOX, GAUSSIAN, MEDIAN, and BILATERAL
	 */
	enum BlurType{
		BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"),
			BILATERAL("Bilateral Filter");

		private final String label;

		BlurType(String label) {
			this.label = label;
		}

		public static BlurType get(String type) {
			if (BILATERAL.label.equals(type)) {
				return BILATERAL;
			}
			else if (GAUSSIAN.label.equals(type)) {
			return GAUSSIAN;
			}
			else if (MEDIAN.label.equals(type)) {
				return MEDIAN;
			}
			else {
				return BOX;
			}
		}

		@Override
		public String toString() {
			return this.label;
		}
	}

	/**
	 * Softens an image using one of several filters.
	 * @param input The image on which to perform the blur.
	 * @param type The blurType to perform.
	 * @param doubleRadius The radius for the blur.
	 * @param output The image in which to store the output.
	 */
	private void blur(Mat input, BlurType type, double doubleRadius,
		Mat output) {
		int radius = (int)(doubleRadius + 0.5);
		int kernelSize;
		switch(type){
			case BOX:
				kernelSize = 2 * radius + 1;
				Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
				break;
			case GAUSSIAN:
				kernelSize = 6 * radius + 1;
				Imgproc.GaussianBlur(input,output, new Size(kernelSize, kernelSize), radius);
				break;
			case MEDIAN:
				kernelSize = 2 * radius + 1;
				Imgproc.medianBlur(input, output, kernelSize);
				break;
			case BILATERAL:
				Imgproc.bilateralFilter(input, output, -1, radius, radius);
				break;
		}
	}




}


